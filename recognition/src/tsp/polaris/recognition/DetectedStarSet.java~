package tsp.polaris.recognition;
import java.util.Arrays;
import tsp.polaris.auxiliaries.Combinatorics;
import tsp.polaris.auxiliaries.Functions;
import tsp.polaris.recognition.exceptions.TriangleMatchingException;

/**
 * Classe représentant une liste d'étoile dans l'image à analyser
 * Cette classe permet notamment de générer des combinaisons d'étoiles
 * et d'identifier l'ensemble d'étoiles correspondant le mieux à une constellation.
 *
 * @author Chadi A., Emma M.
 */
public class DetectedStarSet extends StarSet
{
    /**
     * Constructeur de la classe StarSet.
     *
     * @param stars Liste d'étoiles constituant l'objet.
     */
    public DetectedStarSet(Star[] stars)
    {
        super(stars);
    }

    /**
     * Génère toutes les combinaisons possibles de k étoiles parmi les étoiles disponibles.
     * Cette fonction utilise un algorithme combinatoire base sur un pseudo-code disponible en ligne.
     *
     * @param k Nombre d'étoiles à selectionner.
     * @param resultStars Tableau contenant toutes les combinaisons générées.
     * @param copyStars Copie des étoiles disponibles.
     * @param indice Indice de la combinaison en cours.
     * @param tempStarList Liste temporaire pour stocker les étoiles en cours de combinaison.
     * @see <a href="http://jm.davalan.org/mots/comb/comb/combalgo.html">Pseudo-code utilise (modifie)</a>
     */
    private void combinationStar(int k, Star[][] resultStars, Star[] copyStars, int indice, Star[] tempStarList) {
    	// Cas ou on demande des combinaisons de K parmi N avec K > N
    	if(k > copyStars.length) {
    		return;
    	// Cas ou on a termine de faire une combinaison
    	} else if(k <= 0) {
    		resultStars[indice] = tempStarList;
    	} else {
    		for(int i = 0; i < copyStars.length; i += 1) {
    			// g est la liste des étoiles se situant après l'indice i
    			Star[] g = new Star[copyStars.length - i - 1];
    			for(int j = i+1; j < copyStars.length; j += 1) {
    				g[i] = copyStars[i];
    			}
    			
    			// l2 est la liste tempStarList auquel on rajoute l'élément en indice i de copyStars
    			Star[] l2 = new Star[tempStarList.length + 1];
    			for(int j = 0; j < tempStarList.length; j += 1) {
    				l2[j] = tempStarList[j];
    			}
    			l2[l2.length - 1] = copyStars[i];
    			
    			combinationStar(k-1, resultStars, g, indice+i, l2);
    		}
    	}
    }
    
    /**
     * Recherche la meilleure liste d'étoiles correspondant à une constellation.
     *
     * @param k Nombre d'étoiles à selectionner.
     * @param coutMinParTaille Tableau stockant les coûts minimaux par taille de constellation.
     * @param constellations Liste des constellations de reference.
     * @return La liste d'étoiles ayant le coût minimal.
     * @throws TriangleMatchingException Si une erreur survient lors de l'appariement des constellations.
     */
    public DetectedStarSet findRightListStar(int k, double[] coutMinParTaille, Constellation...constellations) throws TriangleMatchingException {
    	// On cree une liste composee de tous les ensembles d'étoiles à k elements :
    	
    	// Nombre de combinaisons
    	int nbCombination = Combinatorics.combination(stars.length, k);
    	
    	// Liste de toutes les combinaisons de constellations à k étoiles
    	DetectedStarSet[] listeConstellation = new DetectedStarSet[nbCombination];
    	
    	// Liste de toutes les combinaisons de k étoiles
    	Star[][] starsListConstellation = new Star[nbCombination][k];
    	
    	combinationStar(k,starsListConstellation, stars,0,new Star[k]);
    	
    	// On a la liste des combinaisons de toutes les étoiles, il faut maintenant faire de ces listes, des constellations
    	for(int i = 0; i < nbCombination; i += 1) {
    		listeConstellation[i] = new DetectedStarSet(starsListConstellation[i]);
    	}
    	
    	// On cherche l'ensemble d'étoiles de taille k qui ressemble le plus à une constellation -> on regarde le coût minimal
    	double minCoutConstellation = Double.MAX_VALUE;
    	int indConstellation = -1;
    	
    	for(int i = 0; i < listeConstellation.length; i += 1) {
    		double coutCons = listeConstellation[i].coutConstellation(constellations);
    		if(minCoutConstellation > coutCons) {
    			indConstellation = i;
    			minCoutConstellation = coutCons;
    		}
    	}
    	
    	coutMinParTaille[k-3] = minCoutConstellation;
    	return listeConstellation[indConstellation];
    }
    /**
     * Recherche la constellation la plus proche parmi un ensemble de constellations donnees.
     *
     * @param constellations Les constellations à comparer, venant de la base de donnees.
     * @return La liste d'étoiles correspondant à la constellation la plus proche.
     * @throws TriangleMatchingException Si une erreur se produit lors du calcul des coûts des triangles.
     */
    public DetectedStarSet searchConstellation(Constellation... constellations) throws TriangleMatchingException {
    	// On va calculer pour chaque taille possible de constellation, le cout minimal entre toutes les constellations.
    	// LE 10 EST TOTALEMENT ARBITRAIRE, IL FAUDRAIT METTRE LA TAILLE DE LA PLUS GRANDE CONSTELLATION
    	double[] coutMinParTaille = new double[10];
    	// Liste d'étoiles choisies pour chaque constellation
    	DetectedStarSet[] selectedConstellations = new DetectedStarSet[10];
    	// Pour chaque taille d'ensemble d'étoiles, on va chercher l'ensemble d'étoiles qui ressemble le plus à une constellation
    	for(int i = 0; i < 10; i += 1) {
    		selectedConstellations[i] = findRightListStar(i+3,coutMinParTaille,constellations);
    	}
    	// On recherche la taille d'étoiles qui a le cout le plus faible
    	int minIndex = Functions.minIndex(coutMinParTaille);

    	return selectedConstellations[minIndex];
    	
    }

    /**
     * Retourne une representation sous forme de chaîne de caractères des étoiles.
     *
     * @return La chaîne de caractères representant la liste d'étoiles.
     */
    public String toString()
    {
        return Arrays.toString(stars);
    }

    /**
     * Calcule le coût total d'une constellation à partir des coûts des triangles.
     *
     * @param cout_triangle Tableau des coûts des triangles.
     * @return Le coût total de la constellation.
     */
    static double couts(double[] cout_triangle)
    {
        double cout_constellation = 0;
        for (int cout = 0; cout < cout_triangle.length; cout++)
        {
            cout_constellation += cout_triangle[cout];
        }
        return cout_constellation;
    }

    /**
     * Selectionne la constellation avec le coût minimal parmi un ensemble de constellations donnees.
     *
     * @param constellations Les constellations à comparer.
     * @return La constellation avec le coût minimal.
     * @throws TriangleMatchingException Si une erreur se produit lors du calcul des coûts des triangles.
     */
    public String selectConstellation(Constellation... constellations) throws TriangleMatchingException
    {
        // Initialiser le "winner" à null
        Constellation winner = null;
        double minimum_cout = Double.MAX_VALUE; // Utiliser une valeur maximale pour commencer.

        // Parcourir les constellations passees en argument
        for (Constellation c : constellations)
        {
            // Generer les triangles pour la photo et la constellation c
            Triangle[] triangles_photo = generateTriangles(); // Triangles de la photo
            Triangle[] triangles_c = c.generateTriangles();         // Triangles de la constellation c

            ListTriangle listPhoto = new ListTriangle(triangles_photo);
            ListTriangle listTriangle = new ListTriangle(triangles_c);

            // Calculer les coûts entre les triangles de la photo et ceux de la constellation c
            double[] liste_cout = listPhoto.couts(listTriangle);
            double total = couts(liste_cout);  // Calculez le total des coûts

            // Verifiez si le total des coûts de cette constellation est le plus bas
            if (minimum_cout > total)
            {
                minimum_cout = total;  // Mettez à jour le coût minimal
                winner = c;             // Mettez à jour la constellation gagnante
            }
        }
        return winner.getNom();  // Retourner la constellation avec le coût minimal
    }
    
    /**
     * Calcule le coût minimal entre l'ensemble d'étoiles de la photo et un ensemble de constellations donnees.
     *
     * @param constellations Les constellations à comparer.
     * @return Le coût minimal entre la photo et les constellations.
     * @throws TriangleMatchingException Si une erreur se produit lors du calcul des coûts des triangles.
     */
    public double coutConstellation(Constellation... constellations) throws TriangleMatchingException
    {
        double minimum_cout = Double.MAX_VALUE; // Utiliser une valeur maximale pour commencer.

        // Parcourir les constellations passees en argument
        for (Constellation c : constellations)
        {
            // Generer les triangles pour la photo et la constellation c
            Triangle[] triangles_photo = generateTriangles(); // Triangles de la photo
            Triangle[] triangles_c = c.generateTriangles();         // Triangles de la constellation c

            ListTriangle listPhoto = new ListTriangle(triangles_photo);
            ListTriangle listTriangle = new ListTriangle(triangles_c);

            // Calculer les coûts entre les triangles de la photo et ceux de la constellation c
            double[] liste_cout = listPhoto.couts(listTriangle);
            double total = couts(liste_cout);  // Calculez le total des coûts

            // Verifiez si le total des coûts de cette constellation est le plus bas
            if (minimum_cout > total)
            {
                minimum_cout = total;  // Mettez à jour le coût minimal
            }
        }
        return minimum_cout;  // Retourner la constellation avec le coût minimal
    }
}
